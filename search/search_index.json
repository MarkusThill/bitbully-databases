{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BitBully Dabases: xxxxx","text":"<p>BitBully Databases is a xxxx</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#installing-bitbully-databases","title":"Installing BitBully Databases","text":"<p>Install <code>bitbully-databases</code> via pip:</p> LatestVersion x.y.z <pre><code>pip install xxxxx\n</code></pre> <pre><code>pip install xxxxx==x.y.z\n</code></pre>"},{"location":"getting_started/#usage","title":"Usage","text":""},{"location":"getting_started/#simple-example","title":"Simple Example","text":""},{"location":"python/","title":"BitBully API Reference","text":""},{"location":"python/#main","title":"Main","text":"<p>Module for BitBully Databases (no NumPy dependency).</p> <p>This module demonstrates how to read, search, and evaluate binary files containing Connect-4 positions and scores using pure Python (no NumPy). For efficient/production use, prefer the BitBully C++/pybind11 API.</p>"},{"location":"python/#src.bitbully_databases.bitbully_databases.Board","title":"<code>Board = list[list[int]]</code>  <code>module-attribute</code>","text":"<p>Board matrix type.</p> <p>Each entry is an integer: - 0: end-of-column sentinel (no more pieces when scanning bottom\u2192top) - 1: player 1 token - any other non-zero: player 2 token</p>"},{"location":"python/#src.bitbully_databases.bitbully_databases.BitBullyDatabases","title":"<code>BitBullyDatabases</code>","text":"<p>Access and query packaged BitBully opening databases.</p> <p>This class provides a simple, pure-Python interface for exploring and analyzing BitBully database files containing Connect-4 positions and evaluation scores.</p> <p>In typical use, you will only need the static method <code>get_database_path()</code> to retrieve the path to a packaged database file.</p> <p>The remaining methods (e.g., <code>readline</code>, <code>read_book</code>, <code>binary_search</code>, <code>to_huffman</code>, <code>get_book_value</code>) are provided for illustration and educational purposes only. They demonstrate the binary format and logic of BitBully database files in a transparent, Pythonic way.</p> <p>For performance-critical or production use, rely instead on the official BitBully API, which implements the same functionality in optimized C++ and exposes it to Python via pybind11. The C++ implementation is substantially faster and more memory-efficient than the pure-Python examples shown here.</p> Source code in <code>src/bitbully_databases/bitbully_databases.py</code> <pre><code>class BitBullyDatabases:\n    \"\"\"Access and query packaged BitBully opening databases.\n\n    This class provides a simple, pure-Python interface for exploring and analyzing\n    BitBully database files containing Connect-4 positions and evaluation scores.\n\n    In typical use, you will only need the static method\n    [`get_database_path()`][src.bitbully_databases.bitbully_databases.BitBullyDatabases.get_database_path]\n    to retrieve the path to a packaged database file.\n\n    The remaining methods (e.g., `readline`, `read_book`, `binary_search`,\n    `to_huffman`, `get_book_value`) are provided for **illustration and\n    educational purposes** only. They demonstrate the binary format and logic of\n    BitBully database files in a transparent, Pythonic way.\n\n    For performance-critical or production use, rely instead on the official\n    [BitBully API](https://github.com/MarkusThill/BitBully), which implements the\n    same functionality in optimized C++ and exposes it to Python via **pybind11**.\n    The C++ implementation is substantially faster and more memory-efficient than\n    the pure-Python examples shown here.\n    \"\"\"\n\n    def __init__(self, db_name: Literal[\"default\", \"8-ply\", \"12-ply\", \"12-ply-dist\"] | None = None) -&gt; None:\n        \"\"\"Initialize an instance and (optionally) load a database.\n\n        Args:\n            db_name (Literal[\"default\", \"8-ply\", \"12-ply\", \"12-ply-dist\"] | None):\n                Database to load. Accepted values:\n                - \"default\": 12-ply with distances\n                - \"8-ply\": 8-ply without distances\n                - \"12-ply\": 12-ply without distances\n                - \"12-ply-dist\": 12-ply with distances\n                - None: do not load anything\n        \"\"\"\n        self.db_name = db_name\n        self.book: list[tuple[int, int]] | None = None\n        self.with_distances: bool = False\n        if db_name is not None:\n            db_path = Path(BitBullyDatabases.get_database_path(db_name))\n            self.with_distances = db_name in [\"default\", \"12-ply-dist\"]\n            self.is_8ply = db_name == \"8-ply\"\n            self.book = BitBullyDatabases._read_book(\n                file=db_path,\n                with_distances=self.with_distances,\n                is_8ply=self.is_8ply,\n            )\n\n    @staticmethod\n    def get_database_path(db_name: Literal[\"default\", \"8-ply\", \"12-ply\", \"12-ply-dist\"]) -&gt; str:\n        \"\"\"Return the packaged file path for a given database name.\n\n        Args:\n            db_name (Literal[\"default\", \"8-ply\", \"12-ply\", \"12-ply-dist\"]):\n                Database identifier.\n\n        Returns:\n            str: Absolute path to the packaged binary database file.\n\n        Raises:\n            ValueError: If `db_name` is not one of the supported values.\n        \"\"\"\n        if db_name == \"default\":\n            db_path = files(\"bitbully_databases\").joinpath(\"assets/book_12ply_distances.dat\")\n        elif db_name == \"8-ply\":\n            db_path = files(\"bitbully_databases\").joinpath(\"assets/book_8ply.dat\")\n        elif db_name == \"12-ply\":\n            db_path = files(\"bitbully_databases\").joinpath(\"assets/book_12ply.dat\")\n        elif db_name == \"12-ply-dist\":\n            db_path = files(\"bitbully_databases\").joinpath(\"assets/book_12ply_distances.dat\")\n        else:\n            raise ValueError(\n                f\"Unknown database name: {db_name}. Allowed: Literal['default','8-ply','12-ply','12-ply-dist']\"\n            )\n        with as_file(db_path) as f:\n            return str(f)\n\n    def get_book_value(self, board: Board) -&gt; int | None:\n        \"\"\"Retrieve the score for a given board position.\n\n        Note:\n            Pure-Python lookup is for demonstration; prefer the C++/pybind11 API for performance.\n\n        Args:\n            board (Board):\n                Board matrix shaped rows x cols (e.g., 6 x 7). Entries:\n                0=end-of-column sentinel when scanning bottom\u2192top, 1=player1, else=player2.\n\n        Returns:\n            int | None:\n                Score from the book. If the database stores distances\n                (`with_distances=True`), returns the stored signed distance or `None`\n                if the position is not present. If it does *not* store distances,\n                returns 1 when the position is not present (convention: P1 wins)\n                or the stored value if present.\n\n        Raises:\n            ValueError: If no database is loaded.\n        \"\"\"\n        if self.book is None:\n            raise ValueError(\"No database loaded; cannot get book value.\")\n        return BitBullyDatabases._get_book_value(board, self.book, with_distances=self.with_distances)\n\n    def get_book_size(self) -&gt; int | None:\n        \"\"\"Return the number of entries in the loaded book.\n\n        Returns:\n            int | None: Number of entries or `None` if no book is loaded.\n\n        Raises:\n            ValueError: If no database is loaded.\n        \"\"\"\n        if self.book is None:\n            raise ValueError(\"No database loaded; cannot determine book size.\")\n        return len(self.book) if self.book is not None else None\n\n    def get_book_memory_size(self) -&gt; int | None:\n        \"\"\"Return the approximate memory size of the loaded book list.\n\n        Returns:\n            int | None: Size in bytes (via :func:`sys.getsizeof`) or `None` if not loaded.\n\n        Raises:\n            ValueError: If no database is loaded.\n        \"\"\"\n        if self.book is None:\n            raise ValueError(\"No database loaded; cannot determine book memory size.\")\n        return sys.getsizeof(self.book) if self.book is not None else None\n\n    def has_win_distances(self) -&gt; bool:\n        \"\"\"Indicate whether the loaded database stores winning distances (scores) separately.\n\n        Returns:\n            bool: True if winning distances are stored in the database.\n\n        Raises:\n            ValueError: If no database is loaded.\n        \"\"\"\n        if self.book is None:\n            raise ValueError(\"No database loaded; cannot determine if it has win distances.\")\n        return self.with_distances\n\n    # ---------- Binary file reading ----------\n\n    @staticmethod\n    def _readline(f: BinaryIO, with_distances: bool, is_8ply: bool) -&gt; tuple[int | None, int | None]:\n        \"\"\"Read a single (position, score) entry; return (None, None) on EOF.\n\n        Args:\n            f (BinaryIO): Open binary file handle (positioned at the next entry).\n            with_distances (bool): Whether scores are stored in a trailing byte.\n            is_8ply (bool): Whether entries are in 3 bytes (8-ply) vs 4 bytes.\n\n        Returns:\n            tuple[int | None, int | None]: (huffman_position, score), or (None, None) at EOF.\n        \"\"\"\n        bytes_position = 3 if is_8ply else 4\n        x = f.read(bytes_position)\n        if not x:\n            return None, None  # EOF\n\n        huffman_position = int.from_bytes(x, byteorder=\"big\", signed=not is_8ply)\n        if with_distances:\n            score = int.from_bytes(f.read(1), byteorder=\"big\", signed=True)\n        else:\n            # Last two bits encode the score; convention: multiply by -1.\n            score = (huffman_position &amp; 3) * (-1)\n            huffman_position = (huffman_position // 4) * 4  # zero-out last 2 bits\n        return huffman_position, score\n\n    @staticmethod\n    def _read_book(file: Path, with_distances: bool = True, is_8ply: bool = False) -&gt; list[tuple[int, int]]:\n        \"\"\"Read the entire binary book into memory.\n\n        Args:\n            file (Path): Path to the binary book file.\n            with_distances (bool): Whether scores are stored in a separate byte.\n            is_8ply (bool): Whether entries are 3 bytes (8-ply) vs 4 bytes.\n\n        Returns:\n            list[tuple[int, int]]: List of (huffman_position, score) in ascending position order.\n        \"\"\"\n        book: list[tuple[int, int]] = []\n        with Path.open(file, \"rb\") as f:\n            while True:\n                position, score = BitBullyDatabases._readline(f, with_distances, is_8ply)\n                if position is None:\n                    break\n                if score is None:\n                    continue  # should not happen...\n                book.append((position, score))\n        return book\n\n    # ---------- Lookup helpers ----------\n\n    @staticmethod\n    def _binary_search(book: list[tuple[int, int]], huffman_position: int) -&gt; int | None:\n        \"\"\"Binary search for a position in a sorted book.\n\n        Args:\n            book (list[tuple[int, int]]): Sorted list of (position, score) pairs.\n            huffman_position (int): Target position to look up.\n\n        Returns:\n            int | None: Score if found, else None.\n        \"\"\"\n        left = 0\n        right = len(book) - 1\n        while right &gt;= left:\n            mid = (left + right + 1) // 2\n            p = book[mid][0]\n            if p == huffman_position:\n                return book[mid][1]\n            if p &gt; huffman_position:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return None\n\n    # ---------- Board encoding (no NumPy) ----------\n\n    @staticmethod\n    def _dims(board: Board) -&gt; tuple[int, int]:\n        \"\"\"Return (rows, cols) and perform a minimal rectangularity check.\n\n        Args:\n            board (Board): Board matrix.\n\n        Returns:\n            tuple[int, int]: (rows, cols).\n\n        Raises:\n            ValueError: If the board has zero rows or rows with differing lengths.\n        \"\"\"\n        rows = len(board)\n        if rows == 0:\n            raise ValueError(\"Board must have at least one row.\")\n        cols = len(board[0])\n        for r in board:\n            if len(r) != cols:\n                raise ValueError(\"Board rows must all have the same length.\")\n        return rows, cols\n\n    @staticmethod\n    def _to_huffman(board: Board) -&gt; int:\n        \"\"\"Convert a board to its Huffman-encoded integer.\n\n        Iteration order:\n            Columns left\u2192right; within each column, rows bottom\u2192top.\n\n        Encoding:\n            - 0 \u2192 end-of-column sentinel (separator bit '0')\n            - 1 \u2192 player 1 token ('10')\n            - any other non-zero \u2192 player 2 token ('11')\n\n        Args:\n            board (Board): Board matrix.\n\n        Returns:\n            int: Signed 32-bit-compatible integer encoding of the board.\n        \"\"\"\n        rows, cols = BitBullyDatabases._dims(board)\n\n        bits: list[str] = [\"0b\"]\n        for c in range(cols):  # e.g., 0..6 for 7 columns\n            for r in range(rows):  # e.g., 0..5 for 6 rows\n                v = board[r][c]\n                if v == 0:\n                    bits.append(\"0\")  # separator for end-of-column\n                    break\n                if v == 1:\n                    bits.append(\"10\")  # P1 token (2 bits)\n                else:\n                    bits.append(\"11\")  # P2 token (2 bits)\n                if r == rows - 1:\n                    bits.append(\"0\")  # column full \u2192 still add separator\n\n        bits.append(\"0\")  # pad to full byte as original logic does\n        s = \"\".join(bits)\n        val = int(s, 2)\n        # If first payload bit is '1' and total exceeds 32 bits, adjust to signed 32-bit (two's complement).\n        if s[2] == \"1\" and len(s) &gt; 32:\n            val -= 2 &lt;&lt; 31  # 2**32\n        return val\n\n    @staticmethod\n    def _mirror_horiz(board: Board) -&gt; Board:\n        \"\"\"Return a horizontally mirrored copy of the board (flip columns).\n\n        Args:\n            board (Board): Board matrix.\n\n        Returns:\n            Board: New board matrix mirrored along the vertical axis.\n        \"\"\"\n        rows, cols = BitBullyDatabases._dims(board)\n        mirrored: Board = [[0] * cols for _ in range(rows)]\n        for r in range(rows):\n            for c in range(cols):\n                mirrored[r][cols - 1 - c] = board[r][c]\n        return mirrored\n\n    @staticmethod\n    def _get_book_value(board: Board, book: list[tuple[int, int]], with_distances: bool = True) -&gt; int | None:\n        \"\"\"Lookup score via Huffman encoding, trying both the board and its mirror.\n\n        Args:\n            board (Board): Board matrix.\n            book (list[tuple[int, int]]): Database as (position, score) pairs.\n            with_distances (bool): Whether the database stores distances separately.\n\n        Returns:\n            int | None:\n                Score for the board. If `with_distances` is False and the position is\n                not found, returns 1 (convention: P1 wins). Otherwise returns None if\n                not found.\n        \"\"\"\n        p = BitBullyDatabases._to_huffman(board)\n        val = BitBullyDatabases._binary_search(book, p)\n        if val is not None:\n            return val\n\n        p_m = BitBullyDatabases._to_huffman(BitBullyDatabases._mirror_horiz(board))\n        val = BitBullyDatabases._binary_search(book, p_m)\n\n        if not with_distances and val is None:\n            # In 8/12-ply books without distances: missing \u21d2 P1 wins\n            return 1\n        return val\n</code></pre>"},{"location":"python/#src.bitbully_databases.bitbully_databases.BitBullyDatabases.__init__","title":"<code>__init__(db_name=None)</code>","text":"<p>Initialize an instance and (optionally) load a database.</p> <p>Parameters:</p> Name Type Description Default <code>db_name</code> <code>Literal['default', '8-ply', '12-ply', '12-ply-dist'] | None</code> <p>Database to load. Accepted values: - \"default\": 12-ply with distances - \"8-ply\": 8-ply without distances - \"12-ply\": 12-ply without distances - \"12-ply-dist\": 12-ply with distances - None: do not load anything</p> <code>None</code> Source code in <code>src/bitbully_databases/bitbully_databases.py</code> <pre><code>def __init__(self, db_name: Literal[\"default\", \"8-ply\", \"12-ply\", \"12-ply-dist\"] | None = None) -&gt; None:\n    \"\"\"Initialize an instance and (optionally) load a database.\n\n    Args:\n        db_name (Literal[\"default\", \"8-ply\", \"12-ply\", \"12-ply-dist\"] | None):\n            Database to load. Accepted values:\n            - \"default\": 12-ply with distances\n            - \"8-ply\": 8-ply without distances\n            - \"12-ply\": 12-ply without distances\n            - \"12-ply-dist\": 12-ply with distances\n            - None: do not load anything\n    \"\"\"\n    self.db_name = db_name\n    self.book: list[tuple[int, int]] | None = None\n    self.with_distances: bool = False\n    if db_name is not None:\n        db_path = Path(BitBullyDatabases.get_database_path(db_name))\n        self.with_distances = db_name in [\"default\", \"12-ply-dist\"]\n        self.is_8ply = db_name == \"8-ply\"\n        self.book = BitBullyDatabases._read_book(\n            file=db_path,\n            with_distances=self.with_distances,\n            is_8ply=self.is_8ply,\n        )\n</code></pre>"},{"location":"python/#src.bitbully_databases.bitbully_databases.BitBullyDatabases.get_book_memory_size","title":"<code>get_book_memory_size()</code>","text":"<p>Return the approximate memory size of the loaded book list.</p> <p>Returns:</p> Type Description <code>int | None</code> <p>int | None: Size in bytes (via :func:<code>sys.getsizeof</code>) or <code>None</code> if not loaded.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no database is loaded.</p> Source code in <code>src/bitbully_databases/bitbully_databases.py</code> <pre><code>def get_book_memory_size(self) -&gt; int | None:\n    \"\"\"Return the approximate memory size of the loaded book list.\n\n    Returns:\n        int | None: Size in bytes (via :func:`sys.getsizeof`) or `None` if not loaded.\n\n    Raises:\n        ValueError: If no database is loaded.\n    \"\"\"\n    if self.book is None:\n        raise ValueError(\"No database loaded; cannot determine book memory size.\")\n    return sys.getsizeof(self.book) if self.book is not None else None\n</code></pre>"},{"location":"python/#src.bitbully_databases.bitbully_databases.BitBullyDatabases.get_book_size","title":"<code>get_book_size()</code>","text":"<p>Return the number of entries in the loaded book.</p> <p>Returns:</p> Type Description <code>int | None</code> <p>int | None: Number of entries or <code>None</code> if no book is loaded.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no database is loaded.</p> Source code in <code>src/bitbully_databases/bitbully_databases.py</code> <pre><code>def get_book_size(self) -&gt; int | None:\n    \"\"\"Return the number of entries in the loaded book.\n\n    Returns:\n        int | None: Number of entries or `None` if no book is loaded.\n\n    Raises:\n        ValueError: If no database is loaded.\n    \"\"\"\n    if self.book is None:\n        raise ValueError(\"No database loaded; cannot determine book size.\")\n    return len(self.book) if self.book is not None else None\n</code></pre>"},{"location":"python/#src.bitbully_databases.bitbully_databases.BitBullyDatabases.get_book_value","title":"<code>get_book_value(board)</code>","text":"<p>Retrieve the score for a given board position.</p> Note <p>Pure-Python lookup is for demonstration; prefer the C++/pybind11 API for performance.</p> <p>Parameters:</p> Name Type Description Default <code>board</code> <code>Board</code> <p>Board matrix shaped rows x cols (e.g., 6 x 7). Entries: 0=end-of-column sentinel when scanning bottom\u2192top, 1=player1, else=player2.</p> required <p>Returns:</p> Type Description <code>int | None</code> <p>int | None: Score from the book. If the database stores distances (<code>with_distances=True</code>), returns the stored signed distance or <code>None</code> if the position is not present. If it does not store distances, returns 1 when the position is not present (convention: P1 wins) or the stored value if present.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no database is loaded.</p> Source code in <code>src/bitbully_databases/bitbully_databases.py</code> <pre><code>def get_book_value(self, board: Board) -&gt; int | None:\n    \"\"\"Retrieve the score for a given board position.\n\n    Note:\n        Pure-Python lookup is for demonstration; prefer the C++/pybind11 API for performance.\n\n    Args:\n        board (Board):\n            Board matrix shaped rows x cols (e.g., 6 x 7). Entries:\n            0=end-of-column sentinel when scanning bottom\u2192top, 1=player1, else=player2.\n\n    Returns:\n        int | None:\n            Score from the book. If the database stores distances\n            (`with_distances=True`), returns the stored signed distance or `None`\n            if the position is not present. If it does *not* store distances,\n            returns 1 when the position is not present (convention: P1 wins)\n            or the stored value if present.\n\n    Raises:\n        ValueError: If no database is loaded.\n    \"\"\"\n    if self.book is None:\n        raise ValueError(\"No database loaded; cannot get book value.\")\n    return BitBullyDatabases._get_book_value(board, self.book, with_distances=self.with_distances)\n</code></pre>"},{"location":"python/#src.bitbully_databases.bitbully_databases.BitBullyDatabases.get_database_path","title":"<code>get_database_path(db_name)</code>  <code>staticmethod</code>","text":"<p>Return the packaged file path for a given database name.</p> <p>Parameters:</p> Name Type Description Default <code>db_name</code> <code>Literal['default', '8-ply', '12-ply', '12-ply-dist']</code> <p>Database identifier.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Absolute path to the packaged binary database file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>db_name</code> is not one of the supported values.</p> Source code in <code>src/bitbully_databases/bitbully_databases.py</code> <pre><code>@staticmethod\ndef get_database_path(db_name: Literal[\"default\", \"8-ply\", \"12-ply\", \"12-ply-dist\"]) -&gt; str:\n    \"\"\"Return the packaged file path for a given database name.\n\n    Args:\n        db_name (Literal[\"default\", \"8-ply\", \"12-ply\", \"12-ply-dist\"]):\n            Database identifier.\n\n    Returns:\n        str: Absolute path to the packaged binary database file.\n\n    Raises:\n        ValueError: If `db_name` is not one of the supported values.\n    \"\"\"\n    if db_name == \"default\":\n        db_path = files(\"bitbully_databases\").joinpath(\"assets/book_12ply_distances.dat\")\n    elif db_name == \"8-ply\":\n        db_path = files(\"bitbully_databases\").joinpath(\"assets/book_8ply.dat\")\n    elif db_name == \"12-ply\":\n        db_path = files(\"bitbully_databases\").joinpath(\"assets/book_12ply.dat\")\n    elif db_name == \"12-ply-dist\":\n        db_path = files(\"bitbully_databases\").joinpath(\"assets/book_12ply_distances.dat\")\n    else:\n        raise ValueError(\n            f\"Unknown database name: {db_name}. Allowed: Literal['default','8-ply','12-ply','12-ply-dist']\"\n        )\n    with as_file(db_path) as f:\n        return str(f)\n</code></pre>"},{"location":"python/#src.bitbully_databases.bitbully_databases.BitBullyDatabases.has_win_distances","title":"<code>has_win_distances()</code>","text":"<p>Indicate whether the loaded database stores winning distances (scores) separately.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if winning distances are stored in the database.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no database is loaded.</p> Source code in <code>src/bitbully_databases/bitbully_databases.py</code> <pre><code>def has_win_distances(self) -&gt; bool:\n    \"\"\"Indicate whether the loaded database stores winning distances (scores) separately.\n\n    Returns:\n        bool: True if winning distances are stored in the database.\n\n    Raises:\n        ValueError: If no database is loaded.\n    \"\"\"\n    if self.book is None:\n        raise ValueError(\"No database loaded; cannot determine if it has win distances.\")\n    return self.with_distances\n</code></pre>"},{"location":"user_guide/","title":"BitBully User Guide","text":""}]}